import request from 'supertest';
import express, { Express } from 'express';
import mongoose from 'mongoose';
import { addTagController, getAllTagsController, editTagController, deleteTagController } from '../../controller/tagController';
import { addTag, getAllTags, editTag, deleteTag } from '../../db/tagService';

jest.mock('../../db/tagService');

beforeEach(() => {
  jest.spyOn(console, 'error').mockImplementation(() => {});
});
afterEach(() => {
  jest.restoreAllMocks();
});

describe('Tag Controller', () => {
  let app: Express;
  
  beforeAll(() => {
    app = express();
    app.use(express.json());
    app.post('/tags', addTagController);
    app.get('/tags/:transactionId', getAllTagsController);
    app.put('/tags/:id', editTagController);
    app.delete('/tags/:id', deleteTagController);
  });

  describe('POST /tags', () => {
    it('should successfully create a tag', async () => {
      const mockTag = { _id: new mongoose.Types.ObjectId(), name: 'testTag', color: 'red' };
      (addTag as jest.Mock).mockResolvedValue(mockTag);

      const response = await request(app)
        .post('/tags')
        .send({ transactionId: 'trans123', name: 'testTag', color: 'red' });

      expect(response.status).toBe(201);
      expect(response.body.message).toBe('Tag created successfully');
      expect(response.body.tag.id).toBe(mockTag._id.toString());
      expect(response.body.tag.name).toBe('testTag');
      expect(response.body.tag.color).toBe('red');
    });

    it('should return an error when tag creation fails', async () => {
      (addTag as jest.Mock).mockRejectedValue(new Error('Error creating tag'));

      const response = await request(app)
        .post('/tags')
        .send({ transactionId: 'trans123', name: 'testTag', color: 'red' });

      expect(response.status).toBe(500);
      expect(response.body.error).toBe('Error creating tag');
    });
  });

  describe('GET /tags/:transactionId', () => {
    //example test case generated by AI
    it('should successfully retrieve all tags', async () => {
      const mockTags = [
        { _id: new mongoose.Types.ObjectId(), name: 'tag1', color: 'blue' },
        { _id: new mongoose.Types.ObjectId(), name: 'tag2', color: 'green' },
      ];
      (getAllTags as jest.Mock).mockResolvedValue(mockTags);

      const response = await request(app).get('/tags/trans123');

      expect(response.status).toBe(200);
      expect(response.body.length).toBe(2);
      expect(response.body[0].name).toBe('tag1');
      expect(response.body[0].color).toBe('blue');
    });

    it('should return an error when retrieving tags fails', async () => {
      (getAllTags as jest.Mock).mockRejectedValue(new Error('Error retrieving tags'));

      const response = await request(app).get('/tags/trans123');

      expect(response.status).toBe(500);
      expect(response.body.error).toBe('Error retrieving tags');
    });
  });

  describe('PUT /tags/:id', () => {
    it('should successfully update a tag', async () => {
      const mockTag = { _id: new mongoose.Types.ObjectId(), name: 'updatedTag', color: 'yellow' };
      (editTag as jest.Mock).mockResolvedValue(mockTag);

      const response = await request(app)
        .put(`/tags/${mockTag._id}`)
        .send({ name: 'updatedTag', color: 'yellow' });

      expect(response.status).toBe(200);
      expect(response.body.message).toBe('Tag updated successfully');
      expect(response.body.tag.id).toBe(mockTag._id.toString());
      expect(response.body.tag.name).toBe('updatedTag');
      expect(response.body.tag.color).toBe('yellow');
    });

    it('should return 404 when the tag to update is not found', async () => {
      (editTag as jest.Mock).mockResolvedValue(null);

      const response = await request(app)
        .put('/tags/someInvalidId')
        .send({ name: 'updatedTag', color: 'yellow' });

      expect(response.status).toBe(404);
      expect(response.body.message).toBe('Tag not found');
    });

    it('should return an error when updating a tag fails', async () => {
      (editTag as jest.Mock).mockRejectedValue(new Error('Error updating tag'));

      const response = await request(app)
        .put('/tags/someId')
        .send({ name: 'updatedTag', color: 'yellow' });

      expect(response.status).toBe(500);
      expect(response.body.error).toBe('Error updating tag');
    });
  });

  describe('DELETE /tags/:id', () => {
    it('should successfully delete a tag', async () => {
      const mockResult = { deletedCount: 1 };
      (deleteTag as jest.Mock).mockResolvedValue(mockResult);

      const response = await request(app).delete('/tags/validTagId');

      expect(response.status).toBe(200);
      expect(response.body.message).toBe('Tag deleted successfully');
    });

    it('should return 404 when the tag to delete is not found', async () => {
      const mockResult = { deletedCount: 0 };
      (deleteTag as jest.Mock).mockResolvedValue(mockResult);

      const response = await request(app).delete('/tags/nonExistentTagId');

      expect(response.status).toBe(404);
      expect(response.body.message).toBe('Tag not found');
    });

    it('should return an error when deleting a tag fails', async () => {
      (deleteTag as jest.Mock).mockRejectedValue(new Error('Error deleting tag'));

      const response = await request(app).delete('/tags/someId');

      expect(response.status).toBe(500);
      expect(response.body.error).toBe('Error deleting tag');
    });
  });

  afterAll(() => {
    jest.restoreAllMocks();
  });
});
