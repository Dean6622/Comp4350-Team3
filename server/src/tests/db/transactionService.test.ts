import {MongoMemoryServer} from "mongodb-memory-server";
import mongoose from "mongoose";
import User from "../../db/userDB";
import Tag from "../../db/tagDB";
import {addTransaction, getAllTransactions, editTransaction, deleteTransaction} from "../../db/transactionService";

// Test settings assisted by AI
beforeEach(() => {
  jest.spyOn(console, "error").mockImplementation(() => {});
});
afterEach(() => {
  jest.restoreAllMocks();
});

describe("Transaction Service Tests", () => {
  let userId:string;
  let tagId:string;
  let mongoServer:MongoMemoryServer;

  beforeAll(async () => {
    mongoServer = await MongoMemoryServer.create();
    const mongoUri = mongoServer.getUri();
    await mongoose.connect(mongoUri);
  });

  afterAll(async () => {
    await mongoose.disconnect();
    await mongoServer.stop();
  });

  beforeEach(async () => {
    await User.deleteMany({});

    const user = new User({
      username: `testuser_${Date.now()}`,
      password: "testpassword",
      name: "Test User",
      balance: 1000,
    });
    await user.save();
    userId = user._id;

    const tag = new Tag({user: userId, name: "Food", color: "#FF5733"});
    await tag.save();
    tagId = tag._id;
  });

  it("should not add a transaction with missing required fields", async () => {
    try {
      await addTransaction(userId.toString(), "", "2025-03-20", 100, "USD", "", [tagId.toString()]);
    } catch (err) {
      expect(err.message).toBe("Validation Error: Path `name` is required., Path `type` is required.");
    }
  });

  // Example test case generated by AI
  it("should retrieve all transactions for a user", async () => {
    await addTransaction(userId.toString(), "Groceries", "2025-03-20", 100, "USD", "Spending", [tagId.toString()]);
    await addTransaction(userId.toString(), "Salary", "2025-03-21", 2000, "USD", "Saving", []);

    const transactions = await getAllTransactions(userId.toString());
    expect(transactions).toHaveLength(2);
    expect(transactions[0]).toHaveProperty("name", "Groceries");
    expect(transactions[1]).toHaveProperty("name", "Salary");
  });

  it("should not add a transaction with invalid date format", async () => {
    try {
      await addTransaction(userId.toString(), "Groceries", "2025-20-03", 100, "USD", "Spending", [tagId.toString()]);
    } catch (err) {
      expect(err.message).toMatch(
        /Validation Error: Cast to date failed for value "Invalid Date" \(type Date\) at path "date"/,
      );
    }
  });

  // Example test case generated by AI
  it("should handle multiple tags for a transaction", async () => {
    const tag2 = new Tag({user: userId, name: "Health", color: "#00FF00"});
    await tag2.save();

    const transaction = await addTransaction(userId.toString(), "Groceries", "2025-03-20", 100, "USD", "Spending", [tagId.toString(), tag2._id.toString()]);

    expect(transaction).toHaveProperty("_id");
    expect(transaction.tags).toHaveLength(2);
  });

  it("should not allow a transaction to have tags that do not exist", async () => {
    const invalidTagId = new mongoose.Types.ObjectId();
    try {
      await addTransaction(userId.toString(), "Groceries", "2025-03-20", 100, "USD", "Spending", [invalidTagId.toString()]);
    } catch (err) {
      expect(err.message).toMatch("One or more tags do not exist.");
    }
  });

  it("should update transaction with invalid data", async () => {
    const transaction = await addTransaction(userId.toString(), "Groceries", "2025-03-20", 100, "USD", "Spending", [tagId.toString()]);
    try {
      await editTransaction(transaction._id, "", "2025-03-20", -100, "USD", "Spending", [tagId.toString()]);
    } catch (err) {
      expect(err.message).toBe("Validation Error: Amount must be a positive number");
    }
  });

  it("should not delete a transaction that does not exist", async () => {
    const invalidTransactionId = new mongoose.Types.ObjectId();
    try {
      await deleteTransaction(invalidTransactionId.toString());
    } catch (err) {
      expect(err.message).toMatch(new RegExp(`No transaction found with ID ${invalidTransactionId.toString()}`));
    }
  });

  it("should reject a tag with invalid color code (not hex)", async () => {
    try {
      const invalidTag = new Tag({user: userId, name: "Invalid Color", color: "notAHexColor"});
      await invalidTag.save();
    } catch (err) {
      expect(err.message).toMatch(/Path `color` is invalid/);
    }
  });

  it("should reject a tag with a color shorter than 7 characters", async () => {
    try {
      const invalidTag = new Tag({user: userId, name: "Short Color", color: "#12345"});
      await invalidTag.save();
    } catch (err) {
      expect(err.message).toMatch(/Path `color` is invalid/);
    }
  });

  it("should not add a transaction if user balance is insufficient", async () => {
    const user = await User.findById(userId);
    user.balance = 50;
    await user.save();

    try {
      await addTransaction(userId.toString(), "Groceries", "2025-03-20", 100, "USD", "Spending", [tagId.toString()]);
    } catch (err) {
      expect(err.message).toBe("Insufficient balance for spending.");
    }
  });

  it("should throw an error when an invalid transaction ID is passed in editTransaction", async () => {
    try {
      await editTransaction("invalid-id", "Rent", "2025-03-20", 100, "USD", "Spending", [tagId.toString()]);
    } catch (err) {
      expect(err.message).toBe("Invalid transaction ID format");
    }
  });
  
  it("should throw an error when an invalid transaction ID is passed in deleteTransaction", async () => {
    try {
      await deleteTransaction("invalid-id");
    } catch (err) {
      expect(err.message).toBe("Invalid transaction ID format");
    }
  });

  it("should return null if the transaction is not found in editTransaction", async () => {
    const invalidTransactionId = new mongoose.Types.ObjectId().toString();
    const result = await editTransaction(invalidTransactionId, "Rent", "2025-03-20", 100, "USD", "Spending", [tagId.toString()]);
    expect(result).toBeNull();
  });
  
  it("should throw an error if the transaction is not found in deleteTransaction", async () => {
    const invalidTransactionId = new mongoose.Types.ObjectId().toString();
    try {
      await deleteTransaction(invalidTransactionId);
    } catch (err) {
      expect(err.message).toBe(`No transaction found with ID ${invalidTransactionId}`);
    }
  });

  it("should throw an error when the user has insufficient balance in editTransaction", async () => {
    const transaction = await addTransaction(userId.toString(), "Rent", "2025-03-20", 1000, "USD", "Spending", [tagId.toString()]);
    const user = await User.findById(userId);
    user.balance = 500; // Setting balance lower than transaction amount
    await user.save();
  
    try {
      await editTransaction(transaction._id.toString(), "Rent", "2025-03-20", 1000, "USD", "Spending", [tagId.toString()]);
    } catch (err) {
      expect(err.message).toBe("Insufficient balance for spending.");
    }
  });

  it("should throw an error if the tags do not exist in editTransaction", async () => {
    const invalidTagId = new mongoose.Types.ObjectId().toString();
    const transaction = await addTransaction(userId.toString(), "Rent", "2025-03-20", 100, "USD", "Spending", [tagId.toString()]);
  
    try {
      await editTransaction(transaction._id.toString(), "Rent", "2025-03-20", 100, "USD", "Spending", [invalidTagId]);
    } catch (err) {
      expect(err.message).toBe("One or more tags do not exist.");
    }
  });

  it("should throw an error when an invalid transaction type is provided in editTransaction", async () => {
    const transaction = await addTransaction(userId.toString(), "Rent", "2025-03-20", 100, "USD", "Spending", [tagId.toString()]);
  
    try {
      await editTransaction(transaction._id.toString(), "Rent", "2025-03-20", 100, "USD", "InvalidType", [tagId.toString()]);
    } catch (err) {
      expect(err.message).toBe("Invalid type. Must be one of: Saving, Spending");
    }
  });

  it("should throw an error when an invalid type is provided in editTransaction", async () => {
    // Create a transaction with a valid type ("Spending")
    const transaction = await addTransaction(userId.toString(), "Rent", "2025-03-20", 100, "USD", "Spending", [tagId.toString()]);
  
    // Try to update the transaction with an invalid type
    try {
      await editTransaction(transaction._id.toString(), "Rent", "2025-03-20", 100, "USD", "InvalidType", [tagId.toString()]);
    } catch (err) {
      expect(err.message).toBe("Invalid type. Must be one of: Saving, Spending");
    }
  });

  it("should throw an error when the user does not exist during transaction update", async () => {
    // Create a transaction with a valid user
    const transaction = await addTransaction(userId.toString(), "Rent", "2025-03-20", 100, "USD", "Spending", [tagId.toString()]);
  
    // Delete the user associated with the transaction
    await User.findByIdAndDelete(userId);
  
    // Try to update the transaction after the user is deleted
    try {
      await editTransaction(transaction._id.toString(), "Rent", "2025-03-20", 100, "USD", "Spending", [tagId.toString()]);
    } catch (err) {
      expect(err.message).toBe("User does not exist.");
    }
  });

  it("should throw an error when a tag does not belong to the user during transaction update", async () => {
    // Create a user and a tag for that user
    const user = new User({
      username: `testuser_${Date.now()}`,
      password: "testpassword",
      name: "Test User",
      balance: 1000,
    });
    await user.save();
    const userId = user._id;
  
    const tag = new Tag({ user: userId, name: "Food", color: "#FF5733" });
    await tag.save();
  
    // Create another user and a tag for that user
    const anotherUser = new User({
      username: `anotheruser_${Date.now()}`,
      password: "anotherpassword",
      name: "Another User",
      balance: 500,
    });
    await anotherUser.save();
    const anotherUserId = anotherUser._id;
  
    const invalidTag = new Tag({ user: anotherUserId, name: "Health", color: "#00FF00" });
    await invalidTag.save();
  
    // Create a transaction with a valid tag from the first user
    const transaction = await addTransaction(userId.toString(), "Groceries", "2025-03-20", 100, "USD", "Spending", [tag._id.toString()]);
  
    // Try to update the transaction with a tag from a different user
    try {
      await editTransaction(transaction._id.toString(), "Groceries", "2025-03-20", 100, "USD", "Spending", [invalidTag._id.toString()]);
    } catch (err) {
      expect(err.message).toBe(`Tag "${invalidTag.name}" does not belong to the user with ID ${userId}`);
    }
  });
  
  it("should handle validation errors correctly", async () => {
    // Simulate a situation where required fields are missing (for example, missing transaction name)
    try {
      await addTransaction(userId.toString(), "", "2025-03-20", 100, "USD", "Spending", []);
    } catch (err) {
      // The error should be a ValidationError, so check for the validation message
      expect(err.message).toMatch(/Validation Error: Path `name` is required/);
    }
  });

  it("should not allow editing a transaction if the user has insufficient balance after an update", async () => {
    const transaction = await addTransaction(userId.toString(), "Groceries", "2025-03-20", 100, "USD", "Spending", [tagId.toString()]);
    const user = await User.findById(userId);
    user.balance = 50; // Insufficient balance for the updated transaction
    await user.save();
  
    try {
      await editTransaction(transaction._id.toString(), "Groceries", "2025-03-20", 100, "USD", "Spending", [tagId.toString()]);
    } catch (err) {
      expect(err.message).toBe("Insufficient balance for spending.");
    }
  });

  it("should throw an error if amount is missing during transaction edit", async () => {
    const transaction = await addTransaction(userId.toString(), "Groceries", "2025-03-20", 100, "USD", "Spending", [tagId.toString()]);
  
    try {
      await editTransaction(transaction._id.toString(), "Groceries", "2025-03-20", undefined, "USD", "Spending", [tagId.toString()]);
    } catch (err) {
      expect(err.message).toBe("Validation Error: Path `amount` is required.");
    }
  });
  
  it("should throw an error if an invalid transaction type is provided in editTransaction", async () => {
    const transaction = await addTransaction(userId.toString(), "Groceries", "2025-03-20", 100, "USD", "Spending", [tagId.toString()]);
    
    try {
      await editTransaction(transaction._id.toString(), "Groceries", "2025-03-20", 100, "USD", "InvalidType", [tagId.toString()]);
    } catch (err) {
      expect(err.message).toBe("Invalid type. Must be one of: Saving, Spending");
    }
  });

  it("should throw an error if tags are missing or invalid in editTransaction", async () => {
    const transaction = await addTransaction(userId.toString(), "Groceries", "2025-03-20", 100, "USD", "Spending", [tagId.toString()]);
    try {
      await editTransaction(transaction._id.toString(), "Groceries", "2025-03-20", 100, "USD", "Spending", []);
    } catch (err) {
      expect(err.message).toBe("One or more tags do not exist.");
    }
  });

  it("should allow removing all tags from a transaction", async () => {
    const transaction = await addTransaction(userId.toString(), "Groceries", "2025-03-20", 100, "USD", "Spending", [tagId.toString()]);
    
    const updatedTransaction = await editTransaction(transaction._id.toString(), "Groceries", "2025-03-20", 100, "USD", "Spending", []);
    expect(updatedTransaction.tags).toHaveLength(0); // Tags should be empty
  });   
});
